package packaging

import (
	"crypto/sha256"
	"fmt"
	"strings"
	"time"

	"QLP/internal/models"
)

func (cp *CapsulePackager) calculateChecksum(data []byte) string {
	hash := sha256.Sum256(data)
	return fmt.Sprintf("%x", hash)
}

func (cp *CapsulePackager) determineMimeType(taskType models.TaskType) string {
	switch taskType {
	case models.TaskTypeCodegen:
		return "text/x-go"
	case models.TaskTypeTest:
		return "text/x-go"
	case models.TaskTypeInfra:
		return "text/x-terraform"
	case models.TaskTypeDoc:
		return "text/markdown"
	case models.TaskTypeAnalyze:
		return "text/plain"
	default:
		return "text/plain"
	}
}

func (cp *CapsulePackager) generateREADME(capsule *QLCapsule) string {
	return fmt.Sprintf(`# QuantumLayer Capsule: %s

Generated on: %s  
Intent: %s  
Capsule ID: %s  

## Overview

This QuantumLayer capsule contains the complete execution results for the intent "%s".

### Execution Summary

- **Total Tasks**: %d
- **Successful**: %d  
- **Failed**: %d
- **Overall Score**: %d/100
- **Execution Time**: %v

### Task Breakdown

%s

### Security Report

- **Overall Risk Level**: %s
- **Security Score**: %d/100
- **Vulnerabilities Found**: %d
- **Critical Issues**: %d

### Quality Report

- **Overall Quality Score**: %d/100
- **Test Coverage**: %.1f%%
- **Documentation Score**: %d/100
- **Lines of Code**: %d

## File Structure

- **manifest.json** - Capsule manifest and metadata
- **metadata.json** - Intent and execution metadata  
- **tasks/** - Individual task execution results
- **outputs/** - Task execution outputs
- **reports/** - Validation and analysis reports
- **sandbox/** - Sandbox execution results
- **validation/** - Per-task validation results

## Usage

This capsule can be imported into compatible QuantumLayer systems or analyzed independently using the provided JSON files.

### Requirements

- Go %s or later
- Docker %s or later
- Minimum %s RAM
- Minimum %s CPU

## Security Considerations

%s

## Quality Recommendations

%s

---

Generated by QuantumLayer Capsule Packager v1.0  
Schema Version: %s  
Compatible with: %s
`,
		capsule.Metadata.CapsuleID,
		capsule.Metadata.CreatedAt.Format(time.RFC3339),
		capsule.Metadata.IntentText,
		capsule.Metadata.CapsuleID,
		capsule.Metadata.IntentText,
		capsule.Metadata.TotalTasks,
		capsule.Metadata.SuccessfulTasks,
		capsule.Metadata.FailedTasks,
		capsule.Metadata.OverallScore,
		capsule.Metadata.Duration,
		cp.formatTaskBreakdown(capsule.ExecutionSummary.TaskBreakdown),
		capsule.SecurityReport.OverallRiskLevel,
		capsule.SecurityReport.SecurityScore,
		capsule.SecurityReport.VulnerabilitiesFound,
		len(capsule.SecurityReport.CriticalIssues),
		capsule.QualityReport.OverallQualityScore,
		capsule.QualityReport.TestCoverageData.OverallCoverage*100,
		capsule.QualityReport.DocumentationScore,
		capsule.QualityReport.CodeQualityMetrics.LinesOfCode,
		capsule.Manifest.Runtime.GoVersion,
		"20.10+", // Docker version
		capsule.Manifest.Runtime.MinMemory,
		capsule.Manifest.Runtime.MinCPU,
		cp.formatSecurityConsiderations(capsule.SecurityReport),
		cp.formatQualityRecommendations(capsule.QualityReport.Recommendations),
		capsule.Manifest.SchemaVersion,
		strings.Join(capsule.Manifest.Compatibility, ", "),
	)
}

func (cp *CapsulePackager) formatTaskBreakdown(breakdown map[models.TaskType]int) string {
	if len(breakdown) == 0 {
		return "No tasks executed"
	}

	var lines []string
	for taskType, count := range breakdown {
		lines = append(lines, fmt.Sprintf("- **%s**: %d task(s)", taskType, count))
	}
	
	return strings.Join(lines, "\n")
}

func (cp *CapsulePackager) formatSecurityConsiderations(report SecurityReport) string {
	if report.OverallRiskLevel == "none" && len(report.CriticalIssues) == 0 {
		return "No significant security issues identified. Regular security reviews are still recommended."
	}

	considerations := []string{}
	
	if report.OverallRiskLevel != "none" {
		considerations = append(considerations, fmt.Sprintf("- Risk level: %s - Review security findings", report.OverallRiskLevel))
	}
	
	if len(report.CriticalIssues) > 0 {
		considerations = append(considerations, fmt.Sprintf("- %d critical security issue(s) require immediate attention", len(report.CriticalIssues)))
	}
	
	for _, action := range report.RecommendedActions {
		considerations = append(considerations, fmt.Sprintf("- %s", action))
	}
	
	if len(considerations) == 0 {
		return "No specific security considerations."
	}
	
	return strings.Join(considerations, "\n")
}

func (cp *CapsulePackager) formatQualityRecommendations(recommendations []QualityRecommendation) string {
	if len(recommendations) == 0 {
		return "No specific quality recommendations. Code quality appears to be satisfactory."
	}

	var lines []string
	for _, rec := range recommendations {
		lines = append(lines, fmt.Sprintf("- **%s** (%s priority): %s", rec.Category, rec.Priority, rec.Description))
	}
	
	return strings.Join(lines, "\n")
}

// File format detection helpers

func (cp *CapsulePackager) detectContentType(content string) string {
	content = strings.TrimSpace(strings.ToLower(content))
	
	// JSON
	if strings.HasPrefix(content, "{") || strings.HasPrefix(content, "[") {
		return "application/json"
	}
	
	// YAML  
	if strings.Contains(content, ":") && (strings.Contains(content, "---") || strings.HasPrefix(content, "apiversion:")) {
		return "application/yaml"
	}
	
	// XML
	if strings.HasPrefix(content, "<?xml") || strings.HasPrefix(content, "<") {
		return "application/xml"
	}
	
	// Markdown
	if strings.Contains(content, "#") || strings.Contains(content, "```") {
		return "text/markdown"
	}
	
	// Go code
	if strings.Contains(content, "package ") || strings.Contains(content, "func ") {
		return "text/x-go"
	}
	
	// Terraform
	if strings.Contains(content, "resource ") || strings.Contains(content, "provider ") {
		return "text/x-terraform"
	}
	
	// SQL
	if strings.Contains(content, "select ") || strings.Contains(content, "create table") {
		return "application/sql"
	}
	
	// Default
	return "text/plain"
}

func (cp *CapsulePackager) estimateFileSize(content string) int64 {
	return int64(len([]byte(content)))
}

func (cp *CapsulePackager) extractCodeLanguage(content string) string {
	content = strings.ToLower(content)
	
	if strings.Contains(content, "package ") && strings.Contains(content, "func ") {
		return "go"
	}
	
	if strings.Contains(content, "resource ") || strings.Contains(content, "variable ") {
		return "terraform"
	}
	
	if strings.Contains(content, "def ") && strings.Contains(content, "import ") {
		return "python"
	}
	
	if strings.Contains(content, "function ") && strings.Contains(content, "var ") {
		return "javascript"
	}
	
	if strings.Contains(content, "class ") && strings.Contains(content, "public ") {
		return "java"
	}
	
	return "text"
}

// Validation helpers

func (cp *CapsulePackager) validateCapsuleStructure(capsule *QLCapsule) error {
	if capsule.Metadata.CapsuleID == "" {
		return fmt.Errorf("capsule ID is required")
	}
	
	if capsule.Metadata.IntentID == "" {
		return fmt.Errorf("intent ID is required")
	}
	
	if len(capsule.Tasks) == 0 {
		return fmt.Errorf("capsule must contain at least one task")
	}
	
	if capsule.Manifest.SchemaVersion == "" {
		return fmt.Errorf("schema version is required")
	}
	
	return nil
}

func (cp *CapsulePackager) sanitizeFilename(filename string) string {
	// Remove or replace invalid characters
	filename = strings.ReplaceAll(filename, "/", "_")
	filename = strings.ReplaceAll(filename, "\\", "_")
	filename = strings.ReplaceAll(filename, ":", "_")
	filename = strings.ReplaceAll(filename, "*", "_")
	filename = strings.ReplaceAll(filename, "?", "_")
	filename = strings.ReplaceAll(filename, "\"", "_")
	filename = strings.ReplaceAll(filename, "<", "_")
	filename = strings.ReplaceAll(filename, ">", "_")
	filename = strings.ReplaceAll(filename, "|", "_")
	
	return filename
}

// Metadata extraction helpers

func (cp *CapsulePackager) extractMetadataFromOutput(output string) map[string]string {
	metadata := make(map[string]string)
	
	// Extract language
	metadata["language"] = cp.extractCodeLanguage(output)
	
	// Extract approximate complexity
	complexity := cp.estimateComplexity(output)
	metadata["complexity"] = fmt.Sprintf("%d", complexity)
	
	// Extract line count
	lines := strings.Split(output, "\n")
	metadata["line_count"] = fmt.Sprintf("%d", len(lines))
	
	// Extract function count
	funcCount := strings.Count(output, "func ")
	metadata["function_count"] = fmt.Sprintf("%d", funcCount)
	
	return metadata
}

func (cp *CapsulePackager) generateArtifactManifest(artifacts []ArtifactReference) map[string]interface{} {
	manifest := map[string]interface{}{
		"total_artifacts": len(artifacts),
		"total_size":      int64(0),
		"artifact_types":  make(map[string]int),
	}
	
	var totalSize int64
	artifactTypes := make(map[string]int)
	
	for _, artifact := range artifacts {
		totalSize += artifact.Size
		artifactTypes[artifact.Type]++
	}
	
	manifest["total_size"] = totalSize
	manifest["artifact_types"] = artifactTypes
	
	return manifest
}